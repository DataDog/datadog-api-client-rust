/*
 * Datadog API V2 Collection
 *
 * Collection of all Datadog Public endpoints.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@datadoghq.com
 * Generated by: https://openapi-generator.tech
 */

/// SpansAttributes : JSON object containing all span attributes and their associated values.



#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct SpansAttributes {
    /// JSON object of attributes from your span.
    #[serde(rename = "attributes", skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, serde_json::Value>>,
    /// JSON object of custom spans data.
    #[serde(rename = "custom", skip_serializing_if = "Option::is_none")]
    pub custom: Option<::std::collections::HashMap<String, serde_json::Value>>,
    /// End timestamp of your span.
    #[serde(rename = "end_timestamp", skip_serializing_if = "Option::is_none")]
    pub end_timestamp: Option<String>,
    /// Name of the environment from where the spans are being sent.
    #[serde(rename = "env", skip_serializing_if = "Option::is_none")]
    pub env: Option<String>,
    /// Name of the machine from where the spans are being sent.
    #[serde(rename = "host", skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The reason why the span was ingested.
    #[serde(rename = "ingestion_reason", skip_serializing_if = "Option::is_none")]
    pub ingestion_reason: Option<String>,
    /// Id of the span that's parent of this span.
    #[serde(rename = "parent_id", skip_serializing_if = "Option::is_none")]
    pub parent_id: Option<String>,
    /// Unique identifier of the resource.
    #[serde(rename = "resource_hash", skip_serializing_if = "Option::is_none")]
    pub resource_hash: Option<String>,
    /// The name of the resource.
    #[serde(rename = "resource_name", skip_serializing_if = "Option::is_none")]
    pub resource_name: Option<String>,
    /// The reason why the span was indexed.
    #[serde(rename = "retained_by", skip_serializing_if = "Option::is_none")]
    pub retained_by: Option<String>,
    /// The name of the application or service generating the span events. It is used to switch from APM to Logs, so make sure you define the same value when you use both products.
    #[serde(rename = "service", skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    /// Whether or not the span was collected as a stand-alone span. Always associated to \"single_span\" ingestion_reason if true.
    #[serde(rename = "single_span", skip_serializing_if = "Option::is_none")]
    pub single_span: Option<bool>,
    /// Id of the span.
    #[serde(rename = "span_id", skip_serializing_if = "Option::is_none")]
    pub span_id: Option<String>,
    /// Start timestamp of your span.
    #[serde(rename = "start_timestamp", skip_serializing_if = "Option::is_none")]
    pub start_timestamp: Option<String>,
    /// Array of tags associated with your span.
    #[serde(rename = "tags", skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// Id of the trace to which the span belongs.
    #[serde(rename = "trace_id", skip_serializing_if = "Option::is_none")]
    pub trace_id: Option<String>,
    /// The type of the span.
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,
}

impl SpansAttributes {
    /// JSON object containing all span attributes and their associated values.
    pub fn new() -> SpansAttributes {
        SpansAttributes {
            attributes: None,
            custom: None,
            end_timestamp: None,
            env: None,
            host: None,
            ingestion_reason: None,
            parent_id: None,
            resource_hash: None,
            resource_name: None,
            retained_by: None,
            service: None,
            single_span: None,
            span_id: None,
            start_timestamp: None,
            tags: None,
            trace_id: None,
            r#type: None,
        }
    }
}


