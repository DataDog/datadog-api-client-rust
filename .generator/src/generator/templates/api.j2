{% include "partial_header.j2" %}

use reqwest;
use crate::datadog::*;

{% for path, method, operation in operations|sort(attribute="2.operationId", case_sensitive=True) %}
{%- set httpMethod = method.upper() %}
{%- set returnType = operation|return_type(version) %}
{%- set formParameter = operation|form_parameter %}
{%- set optionalBody = False if "required" in operation.requestBody and operation.requestBody.required else True %}

{%- for name, parameter in operation|parameters %}
{%- if loop.first %}
/// {{ operation.operationId }}Params is a struct for passing parameters to the method [`{{operation.operationId}}`]
#[derive(Clone, Debug, Default)]
pub struct {{operation.operationId}}Params {
{%- endif %}
    {%- if parameter.description is defined %}
    {{parameter.description | block_comment}}
    {%- endif %}
	{%- if optionalBody and name == operation.get("x-codegen-request-body-name", "body") %}
    pub {{name|variable_name}}: Option<{{ get_type_for_parameter(parameter, version) }}>,
    {%- else %}
    pub {{name|variable_name}}: {{ get_type_for_parameter(parameter, version) }},
    {%- endif %}
{%- if loop.last %}
}
{% endif %}
{%- endfor %}
{%- endfor %}

{% for path, method, operation in operations|sort(attribute="2.operationId", case_sensitive=True) %}
{%- set httpMethod = method.upper() %}
{%- set returnType = operation|return_type(version) %}
{%- set formParameter = operation|form_parameter %}

/// {{ operation.operationId }}Error is a struct for typed errors of method [`{{operation.operationId}}`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum {{operation.operationId}}Error {
	{%- for responseType, (response, responseCodes) in responses_by_types(operation, version) %}
    {%- for responseCode in responseCodes %}
    Status{{responseCode|int}}({{responseType}}),
    {%- endfor %}
    {%- endfor %}
    UnknownValue(serde_json::Value),
}
{% endfor %}

{%- set structName = name|camel_case +"API" %}
#[derive(Debug, Clone)]
pub struct {{ structName }} {
    config: configuration::Configuration,
}

impl Default for {{ structName }} {
    fn default() -> Self {
        Self {
            config: configuration::Configuration::new(),
        }
    }
}

impl {{ structName }} {
    pub fn new() -> Self {
        Self::default()
    }
    pub fn with_config(config: configuration::Configuration) -> Self {
        Self { config }
    }

    {% for path, method, operation in operations|sort(attribute="2.operationId", case_sensitive=True) %}
    {%- set httpMethod = method.upper() %}
    {%- set returnType = operation|return_type(version) %}
    {% if operation.description is defined %}
    {{ operation.description | block_comment }}
    {%- endif %}
    pub async fn {{operation.operationId | snake_case}}(&self{% for name, parameter in operation|parameters %}{% if loop.first %}, params: {{operation.operationId}}Params{% endif %}{% endfor %}) -> Result<Option<{% if returnType %}{{returnType}}{% else %}(){% endif %}>, Error<{{operation.operationId}}Error>> {
        match self.{{operation.operationId | snake_case}}_with_http_info({% for name, parameter in operation|parameters %}{% if loop.first %}params{% endif %}{% endfor %}).await {
            Ok(response_content) => Ok(response_content.entity),
            Err(err) => Err(err),
        }
    }

    {% if operation.description is defined %}
    {{ operation.description | block_comment }}
    {%- endif %}
    pub async fn {{operation.operationId | snake_case}}_with_http_info(&self{% for name, parameter in operation|parameters %}{% if loop.first %}, params: {{operation.operationId}}Params{% endif %}{% endfor %}) -> Result<ResponseContent<{% if returnType %}{{returnType}}{% else %}(){% endif %}>, Error<{{operation.operationId}}Error>> {
        let local_configuration = &self.config;

        // unbox the parameters
        {%- for name, parameter in operation|parameters %}
        let {{name|variable_name}} = params.{{name|variable_name}};
        {%- endfor %}

        let local_client = &local_configuration.client;

        let local_uri_str = format!(
            "{}{{path}}", 
            local_configuration.base_path
            {%- for name, parameter in operation|parameters if parameter.in == "path" %}, {{ name|variable_name }}=
            {%- if parameter.schema.type == "string" %}
            urlencode({{ name|variable_name }}{% if not parameter.required %}.unwrap(){% elif parameter.schema.nullable %}.unwrap(){% endif %}{% if parameter.schema.type == "array" %}.join(",").as_ref(){% endif %})
            {%- else %}
            {{ name|variable_name }}{% if not parameter.required %}.unwrap(){% elif parameter.schema.nullable %}.unwrap(){% endif %}{% if parameter.schema.type == "array" %}.join(",").as_ref(){% endif %}
            {%- endif %}
            {% endfor %});
        let mut local_req_builder = local_client.request(reqwest::Method::{{ httpMethod }}, local_uri_str.as_str());
        {#
        {{#queryParams}}
        {{#required}}
        {{#isArray}}
        local_req_builder = match "{{collectionFormat}}" {
            "multi" => local_req_builder.query(&{{{paramName}}}.into_iter().map(|p| ("{{{baseName}}}".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_req_builder.query(&[("{{{baseName}}}", &{{{paramName}}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
        {{/isArray}}
        {{^isArray}}
        {{^isNullable}}
        local_req_builder = local_req_builder.query(&[("{{{baseName}}}", &{{{paramName}}}.to_string())]);
        {{/isNullable}}
        {{#isNullable}}
        {{#isDeepObject}}
        if let Some(ref local_str) = {{{paramName}}} {
            let params = crate::apis::parse_deep_object("{{{baseName}}}", local_str);
            local_req_builder = local_req_builder.query(&params);
        };
        {{/isDeepObject}}
        {{^isDeepObject}}
        if let Some(ref local_str) = {{{paramName}}} {
            local_req_builder = local_req_builder.query(&[("{{{baseName}}}", &local_str.to_string())]);
        };
        {{/isDeepObject}}
        {{/isNullable}}
        {{/isArray}}
        {{/required}}
        {{^required}}
        if let Some(ref local_str) = {{{paramName}}} {
            {{#isArray}}
            local_req_builder = match "{{collectionFormat}}" {
                "multi" => local_req_builder.query(&local_str.into_iter().map(|p| ("{{{baseName}}}".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
                _ => local_req_builder.query(&[("{{{baseName}}}", &local_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
            };
            {{/isArray}}
            {{^isArray}}
            {{#isDeepObject}}
            let params = crate::apis::parse_deep_object("{{{baseName}}}", local_str);
            local_req_builder = local_req_builder.query(&params);
            {{/isDeepObject}}
            {{^isDeepObject}}
            local_req_builder = local_req_builder.query(&[("{{{baseName}}}", &local_str.to_string())]);
            {{/isDeepObject}}
            {{/isArray}}
        }
        {{/required}}
        {{/queryParams}}
        #}
        if let Some(ref local_user_agent) = local_configuration.user_agent {
            local_req_builder = local_req_builder.header(reqwest::header::USER_AGENT, local_user_agent.clone());
        }
        {#
        {{#hasHeaderParams}}
        {{#headerParams}}
        {{#required}}
        {{^isNullable}}
        local_req_builder = local_req_builder.header("{{{baseName}}}", {{{paramName}}}{{#isArray}}.join(","){{/isArray}}.to_string());
        {{/isNullable}}
        {{#isNullable}}
        match {{{paramName}}} {
            Some(local_param_value) => { local_req_builder = local_req_builder.header("{{{baseName}}}", local_param_value{{#isArray}}.join(","){{/isArray}}.to_string()); },
            None => { local_req_builder = local_req_builder.header("{{{baseName}}}", ""); },
        }
        {{/isNullable}}
        {{/required}}
        {{^required}}
        if let Some(local_param_value) = {{{paramName}}} {
            local_req_builder = local_req_builder.header("{{{baseName}}}", local_param_value{{#isArray}}.join(","){{/isArray}}.to_string());
        }
        {{/required}}
        {{/headerParams}}
        {{/hasHeaderParams}}
        #}
        {%- set authMethods = operation.security if "security" in operation else openapi.security %}
        {%- if authMethods %}
        {%- for authMethod in authMethods %}
        {%- for name in authMethod %}
        {%- set schema = openapi.components.securitySchemes[name] %}
        {%- if schema.type == "apiKey" and schema.in != "cookie" %}
        if let Some(ref local_apikey) = local_configuration.{{name|variable_name}} {
            local_req_builder = local_req_builder.header("{{schema.name}}", local_apikey);
        };
        {%- endif %}
        {%- endfor %}
        {%- endfor %}
        {%- endif %}
        {#
        {{#isMultipart}}
        {{#hasFormParams}}
        let mut local_form = reqwest::multipart::Form::new();
        {{#formParams}}
        {{#isFile}}
        {{^supportAsync}}
        {{#required}}
        {{^isNullable}}
        local_form = local_form.file("{{{baseName}}}", {{{paramName}}})?;
        {{/isNullable}}
        {{#isNullable}}
        match {{{paramName}}} {
            Some(local_param_value) => { local_form = local_form.file("{{{baseName}}}", local_param_value)?; },
            None => { unimplemented!("Required nullable form file param not supported"); },
        }
        {{/isNullable}}
        {{/required}}
        {{^required}}
        if let Some(local_param_value) = {{{paramName}}} {
            local_form = local_form.file("{{{baseName}}}", local_param_value)?;
        }
        {{/required}}
        // TODO: support file upload for '{{{baseName}}}' parameter
        
        {{/isFile}}
        {{^isFile}}
        {{#required}}
        {{^isNullable}}
        local_form = local_form.text("{{{baseName}}}", {{{paramName}}}{{#isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/isArray}}.to_string());
        {{/isNullable}}
        {{#isNullable}}
        match {{{paramName}}} {
            Some(local_param_value) => { local_form = local_form.text("{{{baseName}}}", local_param_value{{#isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/isArray}}.to_string()); },
            None => { local_form = local_form.text("{{{baseName}}}", ""); },
        }
        {{/isNullable}}
        {{/required}}
        {{^required}}
        if let Some(local_param_value) = {{{paramName}}} {
            local_form = local_form.text("{{{baseName}}}", local_param_value{{#isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/isArray}}.to_string());
        }
        {{/required}}
        {{/isFile}}
        {{/formParams}}
        local_req_builder = local_req_builder.multipart(local_form);
        {{/hasFormParams}}
        {{/isMultipart}}
        {{^isMultipart}}
        {{#hasFormParams}}
        let mut local_form_params = std::collections::HashMap::new();
        {{#formParams}}
        {{#isFile}}
        {{#required}}
        {{^isNullable}}
        local_form_params.insert("{{{baseName}}}", unimplemented!("File form param not supported with x-www-form-urlencoded content"));
        {{/isNullable}}
        {{#isNullable}}
        match {{{paramName}}} {
            Some(local_param_value) => { local_form_params.insert("{{{baseName}}}", unimplemented!("File form param not supported with x-www-form-urlencoded content")); },
            None => { unimplemented!("Required nullable file form param not supported with x-www-form-urlencoded content"); },
        }
        {{/isNullable}}
        {{/required}}
        {{^required}}
        if let Some(local_param_value) = {{{paramName}}} {
            local_form_params.insert("{{{baseName}}}", unimplemented!("File form param not supported with x-www-form-urlencoded content"));
        }
        {{/required}}
        {{/isFile}}
        {{^isFile}}
        {{#required}}
        {{^isNullable}}
        local_form_params.insert("{{{baseName}}}", {{{paramName}}}{{#isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/isArray}}.to_string());
        {{/isNullable}}
        {{#isNullable}}
        match {{{paramName}}} {
            Some(local_param_value) => { local_form_params.insert("{{{baseName}}}", local_param_value{{#isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/isArray}}.to_string()); },
            None => { local_form_params.insert("{{{baseName}}}", ""); },
        }
        {{/isNullable}}
        {{/required}}
        {{^required}}
        if let Some(local_param_value) = {{{paramName}}} {
            local_form_params.insert("{{{baseName}}}", local_param_value{{#isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/isArray}}.to_string());
        }
        {{/required}}
        {{/isFile}}
        {{/formParams}}
        local_req_builder = local_req_builder.form(&local_form_params);
        {{/hasFormParams}}
        {{/isMultipart}}
        #}
        {%- if operation.requestBody is defined and not formParameter %}
        {%- set isBodyOptional = False if "required" in operation.requestBody and operation.requestBody.required else True %}
        // body params
        {%- if isBodyOptional %}
        if {{operation.get("x-codegen-request-body-name", "body")|variable_name}}.is_some() {
            local_req_builder = local_req_builder.json(&{{operation.get("x-codegen-request-body-name", "body")|variable_name}}.unwrap());
        }
        {%- else %}
        local_req_builder = local_req_builder.json(&{{operation.get("x-codegen-request-body-name", "body")|variable_name}});
        {%- endif %}
        {%- endif %}

        let local_req = local_req_builder.build()?;
        let local_resp = local_client.execute(local_req).await?;

        let local_status = local_resp.status();
        let local_content = local_resp.text().await?;

        if !local_status.is_client_error() && !local_status.is_server_error() {
            {%- if returnType %}
            let local_entity: Option<{{returnType}}> = serde_json::from_str(&local_content).ok();
            Ok(ResponseContent {
                status: local_status,
                content: local_content,
                entity: local_entity,
            })
            {%- else %}
            Ok(ResponseContent {
                status: local_status,
                content: local_content,
                entity: None,
            })
            {%- endif %}
        } else {
            let local_entity: Option<{{operation.operationId}}Error> = serde_json::from_str(&local_content).ok();
            let local_error = ResponseContent { status: local_status, content: local_content, entity: local_entity };
            Err(Error::ResponseError(local_error))
        }
    }
    {%- endfor %}
}
