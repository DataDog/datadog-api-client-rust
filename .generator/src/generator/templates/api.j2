{% include "partial_header.j2" %}
use reqwest;
use serde::{Serialize, Deserialize};
use crate::datadog::*;
{%- for _, _, operation in operations if "x-unstable" in operation %}
{%- if loop.first %}
use log::warn;
{%- endif %}
{%- endfor %}

{%- set structName = name.replace(" ", "")+"API" %}
{% for path, method, operation in operations|sort(attribute="2.operationId", case_sensitive=true) %}
{%- set httpMethod = method.upper() %}
{%- set returnType = operation|return_type(version) %}
{%- set formParameter = operation|form_parameter %}
{%- set optionalBody = false if "required" in operation.requestBody and operation.requestBody.required else true %}
{%- set optionalParams = operation|parameters|rejectattr('1.required', 'equalto', true) | list %}

{%- for name, parameter in optionalParams %}
{%- if loop.first %}
/// {{operation.operationId}}OptionalParams is a struct for passing parameters to the method [`{{ structName }}::{{operation.operationId | snake_case}}`]
#[non_exhaustive]
#[derive(Clone, Default, Debug)]
pub struct {{operation.operationId}}OptionalParams {
{%- endif %}
    {%- if parameter.description is defined %}
    {{parameter.description | block_comment}}
    {%- endif %}
    pub {{name|variable_name}}: {{ get_type_for_parameter(parameter, version) }},
{%- if loop.last %}
}
{% endif %}
{%- endfor %}
{%- for name, parameter in optionalParams %}
{%- if loop.first %}
impl {{operation.operationId}}OptionalParams {
{%- endif %}
    {%- if parameter.description is defined %}
    {{parameter.description | block_comment}}
    {%- endif %}
    {%- if get_deprecated(model) %}
    #[allow(deprecated)]
    {%- endif %}
    pub fn {{name|variable_name}}(&mut self, value: {{get_type_for_parameter(parameter, version, render_option=false)}}) -> &mut Self {
        self.{{name|variable_name}} = Some(value);
        self
    }
{%- if loop.last %}
}
{% endif %}
{%- endfor %}
{%- endfor %}

{% for path, method, operation in operations|sort(attribute="2.operationId", case_sensitive=true) %}
{%- set httpMethod = method.upper() %}
{%- set returnType = operation|return_type(version) %}
{%- set formParameter = operation|form_parameter %}

/// {{ operation.operationId }}Error is a struct for typed errors of method [`{{ structName }}::{{operation.operationId | snake_case}}`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum {{operation.operationId}}Error {
	{%- for responseType, (response, responseCodes) in responses_by_types(operation, version) %}
    {%- for responseCode in responseCodes %}
    Status{{responseCode|int}}({{responseType}}),
    {%- endfor %}
    {%- endfor %}
    UnknownValue(serde_json::Value),
}
{% endfor %}

#[derive(Debug, Clone)]
pub struct {{ structName }} {
    config: configuration::Configuration,
}

impl Default for {{ structName }} {
    fn default() -> Self {
        Self {
            config: configuration::Configuration::new(),
        }
    }
}

impl {{ structName }} {
    pub fn new() -> Self {
        Self::default()
    }
    pub fn with_config(config: configuration::Configuration) -> Self {
        Self { config }
    }

    {% for path, method, operation in operations|sort(attribute="2.operationId", case_sensitive=true) %}
    {%- set httpMethod = method.upper() %}
    {%- set returnType = operation|return_type(version) %}
    {%- set formParameter = operation|form_parameter %}
    {%- set requiredParams = operation|parameters|selectattr('1.required', 'equalto', true) | list %}
    {% if operation.description is defined %}
    {{ operation.description | block_comment }}
    {%- endif %}
    pub async fn {{operation.operationId | snake_case}}(&self{% for name, parameter in requiredParams %}, {{name|variable_name}}: {{ get_type_for_parameter(parameter, version) }}{% endfor %}{% if operation|has_optional_parameter %}, params: {{operation.operationId}}OptionalParams{% endif %}) -> Result<Option<{% if returnType %}{{returnType}}{% else %}(){% endif %}>, Error<{{operation.operationId}}Error>> {
        match self.{{operation.operationId | snake_case}}_with_http_info({% for name, parameter in requiredParams %}{{name|variable_name}}{% if loop.last %}{% if operation|has_optional_parameter %}, {% endif %}{% else %}, {% endif %}{% endfor %}{% if operation|has_optional_parameter %} params{% endif %}).await {
            Ok(response_content) => Ok(response_content.entity),
            Err(err) => Err(err),
        }
    }

    {% if operation.description is defined %}
    {{ operation.description | block_comment }}
    {%- endif %}
    pub async fn {{operation.operationId | snake_case}}_with_http_info(&self{% for name, parameter in requiredParams %}, {{name|variable_name}}: {{ get_type_for_parameter(parameter, version) }}{% endfor %}{% if operation|has_optional_parameter %}, params: {{operation.operationId}}OptionalParams{% endif %}) -> Result<ResponseContent<{% if returnType %}{{returnType}}{% else %}(){% endif %}>, Error<{{operation.operationId}}Error>> {
        let local_configuration = &self.config;
        {%- if "x-unstable" in operation %}
        let operation_id = "{{ version }}.{{ operation.operationId | snake_case }}".to_string();
        if local_configuration.is_unstable_operation_enabled(&operation_id) {
            warn!("Using unstable operation {}", operation_id);
        } else {
            let local_error = UnstableOperationDisabledError {
                msg: "Operation '{{ version }}.{{ operation.operationId | snake_case }}' is not enabled".to_string(),
            };
            return Err(Error::UnstableOperationDisabledError(local_error));
        }
        {%- endif %}

        {% for name, parameter in operation|parameters if parameter.required != true %}
        {%- if loop.first %}
        // unbox and build optional parameters
        {%- endif %}
        let {{name|variable_name}} = params.{{name|variable_name}};
        {%- endfor %}

        let local_client = &local_configuration.client;

        let local_uri_str = format!(
            "{}{{path}}", 
            local_configuration.get_operation_host("{{ version }}.{{ operation.operationId | snake_case }}")
            {%- for name, parameter in operation|parameters if parameter.in == "path" %}, {{ name|variable_name }}=
            {%- if parameter.schema.type == "string" %}
            urlencode({{ name|variable_name }}{% if not parameter.required %}.unwrap(){% elif parameter.schema.nullable %}.unwrap(){% endif %}{% if parameter.schema.type == "array" %}.join(",").as_ref(){% endif %})
            {%- else %}
            {{ name|variable_name }}{% if not parameter.required %}.unwrap(){% elif parameter.schema.nullable %}.unwrap(){% endif %}{% if parameter.schema.type == "array" %}.join(",").as_ref(){% endif %}
            {%- endif %}
            {% endfor %});
        let mut local_req_builder = local_client.request(reqwest::Method::{{ httpMethod }}, local_uri_str.as_str());

        {% for name, parameter in operation|parameters if parameter.in == "query" %}
        {%- set schema = parameter | parameter_schema %}
        {%- if parameter.required and schema.type == "array" %}
        local_req_builder = local_req_builder.query(&[("{{name}}", &{{name|variable_name}}.iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
        {%- elif not parameter.required and schema.type == "array" %}
        if let Some(ref local) = {{name|variable_name}} {
            local_req_builder = local_req_builder.query(&[("{{name}}", &local.iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
        };
        {%- elif parameter.required %}
        local_req_builder = local_req_builder.query(&[("{{name}}", &{{name|variable_name}}.to_string())]);
        {%- else %}
        if let Some(ref local_query_param) = {{name|variable_name}} {
            local_req_builder = local_req_builder.query(&[("{{name}}", &local_query_param.to_string())]);
        };
        {%- endif %}
        {%- endfor %}

        {% for name, parameter in operation|parameters if parameter.in == "header" %}
        {%- if not parameter.required %}
        if let Some(ref local) = {{name|variable_name}} {
            local_req_builder = local_req_builder.header("{{name}}", &local.to_string());
        };
        {%- else %}
        local_req_builder = local_req_builder.header("{{name}}", &{{name|variable_name}}.to_string());
        {%- endif %}
        {%- endfor %}

        // build user agent
        local_req_builder = local_req_builder.header(reqwest::header::USER_AGENT, local_configuration.user_agent.clone());
        
        // build auth
        {%- set authMethods = operation.security if "security" in operation else openapi.security %}
        {%- if authMethods %}
        {%- for authMethod in authMethods %}
        {%- for name in authMethod %}
        {%- set schema = openapi.components.securitySchemes[name] %}
        {%- if schema.type == "apiKey" and schema.in != "cookie" %}
        if let Some(ref local_apikey) = local_configuration.{{name|variable_name}} {
            local_req_builder = local_req_builder.header("{{schema.name}}", local_apikey);
        };
        {%- endif %}
        {%- endfor %}
        {%- endfor %}
        {%- endif %}

        {% if formParameter %}
        // build form parameters
        {%- if formParameter.required %}
        let mut local_form = reqwest::multipart::Form::new();
        local_form = local_form.part("{{formParameter.name}}", reqwest::multipart::Part::bytes({{formParameter.name}}).file_name("{{formParameter.name}}"));
        local_req_builder = local_req_builder.multipart(local_form);
        {%- else %}
        if let Some({{formParameter.name}}) = {{formParameter.name}} {
            let mut local_form = reqwest::multipart::Form::new();
            local_form = local_form.part("{{formParameter.name}}", reqwest::multipart::Part::bytes({{formParameter.name}}).file_name("{{formParameter.name}}"));
            local_req_builder = local_req_builder.multipart(local_form);
        };
        {%- endif %}
        {%- endif %}

        {%- if operation.requestBody is defined and not formParameter %}
        // build body parameters
        let output = Vec::new();
        let mut ser = serde_json::Serializer::with_formatter(output, DDFormatter);
        if {{operation.get("x-codegen-request-body-name", "body")|variable_name}}.serialize(&mut ser).is_ok() {
            local_req_builder = local_req_builder.body(ser.into_inner());
        }
        {%- endif %}

        let local_req = local_req_builder.build()?;
        let local_resp = local_client.execute(local_req).await?;

        let local_status = local_resp.status();
        let local_content = local_resp.text().await?;

        if !local_status.is_client_error() && !local_status.is_server_error() {
            {%- if returnType %}
            let local_entity: Option<{{returnType}}> = serde_json::from_str(&local_content).ok();
            Ok(ResponseContent {
                status: local_status,
                content: local_content,
                entity: local_entity,
            })
            {%- else %}
            Ok(ResponseContent {
                status: local_status,
                content: local_content,
                entity: None,
            })
            {%- endif %}
        } else {
            let local_entity: Option<{{operation.operationId}}Error> = serde_json::from_str(&local_content).ok();
            let local_error = ResponseContent { status: local_status, content: local_content, entity: local_entity };
            Err(Error::ResponseError(local_error))
        }
    }
    {%- endfor %}
}
