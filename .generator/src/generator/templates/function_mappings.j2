use crate::scenarios::fixtures::DatadogWorld;
use futures::executor::block_on;
use serde_json::Value;
use std::collections::HashMap;

use datadog_api_client::datadog::*;
{%- for version, apis in all_apis.items() %}
use datadog_api_client::datadog{{ version.upper() }};
{%- endfor %}

#[derive(Debug, Default)]
pub struct ApiInstances {
{%- for version, apis in all_apis.items() %}
{%- for name, operations in apis.items() %}
{%- set fieldName = "api_"+name %}
{%- set structName = name|camel_case +"API" %}
    pub {{version}}_{{fieldName | snake_case}}: Option<datadog{{ version.upper() }}::api::{{fieldName | snake_case}}::{{structName}}>,
{%- endfor %}
{%- endfor %}
}

pub fn initialize_api_instance(world: &mut DatadogWorld, api: String) {
    match api.as_str() {
    {%- for name, versions in get_apis_and_versions(all_apis) %}
    {%- set fieldName = "api_"+name|snake_case %}
    {%- set structName = name|camel_case +"API" %}
        "{{name|camel_case}}" => {
        {%- for version in versions %}
            if world.api_instances.{{version}}_{{fieldName}}.is_none() {
                world.api_instances.{{version}}_{{fieldName}} = Some(datadog{{ version.upper() }}::api::{{fieldName}}::{{structName}}::with_config(world.config.clone()));
            }
        {%- endfor %}
        },
    {%- endfor %}
        _ => panic!("{api} API instance not found"),
    }
}

pub fn collect_function_calls(world: &mut DatadogWorld) {
{%- for version, apis in all_apis.items() %}
{%- for _, operations in apis.items() %}
{%- for _, _, operation in operations %}
    world.function_mappings.insert("{{ operation['operationId'] }}".to_string(), test_{{version}}_{{ operation['operationId'] | snake_case }});
{%- endfor %}
{%- endfor %}
{%- endfor %}
}

{%- for version, apis in all_apis.items() %}
{%- for name, operations in apis.items() %}
{%- set apiName = "api_"+name | snake_case %}
{% for _, _, operation in operations %}
{%- set operationParams = operation|parameters|list %}
fn test_{{version}}_{{ operation['operationId'] | snake_case }}(world: &mut DatadogWorld, _parameters: &HashMap<String, Value>) {
    let api = world.api_instances.{{version}}_{{ apiName }}.as_ref().expect("api instance not found");
    {%- if operationParams|length > 0 -%}
    {%- for parameter in operationParams %}
    {%- set schema = parameter[1] | parameter_schema %}
    {%- if parameter[1].required %}
    let {{ parameter[0] | variable_name }} = serde_json::from_value(_parameters.get("{{ parameter[0] }}").unwrap().clone()).unwrap();
    {%- else %}
    let {{ parameter[0] | variable_name }} = if let Some(param) = _parameters.get("{{ parameter[0] }}") {
        {%- if schema | is_primitive -%}
        {%- if schema.get("format") == "binary" -%}
        Some(param.as_str().unwrap().as_bytes().to_vec())
        {%- else -%}
        Some(param.as_str().unwrap().parse().unwrap())
        {%- endif -%}
        {%- else -%}
        serde_json::from_value(param.clone()).unwrap()
        {%- endif -%}
    } else {
        None
    };
    {%- endif %}
    {%- endfor %}
    let params = datadog{{ version.upper() }}::api::{{ apiName }}::{{ operation['operationId'] }}Params {
        {%- for param in operationParams %}
        {{ param[0] | variable_name }},
        {%- endfor %}
    };
    let response = match block_on(api.{{ operation['operationId'] | snake_case}}_with_http_info(params)) {
    {%- else %}
    let response = match block_on(api.{{ operation['operationId'] | snake_case}}_with_http_info()) {
    {%- endif %}
        Ok(response) => response,
        Err(error) => {
            return match error {
                Error::ResponseError(e) => world.response.code = e.status.as_u16(),
                _ => panic!("error parsing response: {}", error),
            };
        }
    };
    world.response.object = serde_json::to_value(response.entity).unwrap();
    world.response.code = response.status.as_u16();
}
{% endfor %}
{%- endfor %}
{%- endfor %}
